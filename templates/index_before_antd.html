
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DeepSeek R1 Unfiltered</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: Inter, system-ui, Arial, sans-serif; margin: 0; background: radial-gradient(circle at top, #26223b, #0b0b0c 55%); color: #eaeaea; display: flex; min-height: 100vh; overflow-x: hidden; }
    #sidebar { width: 280px; flex-shrink: 0; background: #1a1b1f; border-right: 1px solid #292a33; display: flex; flex-direction: column; }
    #sidebar-header { padding: 16px; border-bottom: 1px solid #292a33; display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    #new-chat, #save-chat { background: none; border: 1px solid #343541; color: #ececf1; cursor: pointer; padding: 8px 10px; border-radius: 6px; font-size: 14px; transition: background 0.15s ease; }
    #new-chat:hover, #save-chat:hover { background: #343541; }
    #save-chat.saving { opacity: .6; cursor: progress; }
    #history-wrapper { flex: 1; overflow-y: auto; padding: 12px 10px 18px; display: flex; flex-direction: column; }
    #chat-history { flex: 1; display: flex; flex-direction: column; gap: 6px; }
    .chat-item { padding: 12px 14px; cursor: pointer; border-radius: 8px; display: flex; align-items: center; gap: 10px; border: 1px solid transparent; transition: background .15s ease, border .15s ease; }
    .chat-item:hover { background: #2b2c33; border: 1px solid rgba(255,255,255,0.04); }
    .chat-item.active { background: #343541; border: 1px solid rgba(255,255,255,0.08); }
    .chat-title { flex: 1; font-size: 14px; }
    .chat-delete { background: none; border: none; color: #8b8b93; font-size: 16px; cursor: pointer; padding: 4px; line-height: 1; border-radius: 4px; }
    .chat-delete:hover { color: #fff; background: rgba(255,255,255,0.08); }
    #main { flex: 1; min-width: 0; display: flex; flex-direction: column; overflow: hidden; }
    #chat-container { flex: 1; min-height: 0; width: 100%; overflow-y: auto; padding: 32px 24px 140px; display: flex; justify-content: center; align-items: flex-start; }
    #output-wrapper { width: min(760px, 100%); min-width: 0; display: flex; flex-direction: column; gap: 20px; margin: 0 auto; }
    #output { display: flex; flex-direction: column; gap: 20px; width: 100%; }
    #input-area { position: sticky; bottom: 0; padding: 22px 24px 26px; border-top: 1px solid #292a33; background: linear-gradient(180deg, rgba(14,14,16,0.95), rgba(10,10,11,0.98)); }
    .bar { display: flex; gap: 12px; }
    #input-area .bar { max-width: min(760px, 100%); margin: 0 auto; width: 100%; }
    input[type=text] { flex: 1; padding: 16px; font-size: 16px; border-radius: 12px; border: 1px solid #2a2a2d; background: #151518; color: #fff; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03); }
    button { padding: 12px 18px; font-size: 16px; border-radius: 12px; border: 0; background: #6e60ff; color: #fff; cursor: pointer; transition: background .15s ease, transform .15s ease; }
    button:hover:not(:disabled) { background: #8b7bff; transform: translateY(-1px); }
    button:disabled { opacity: .6; cursor: not-allowed; }
    #output { display: flex; flex-direction: column; gap: 18px; }
    .note { font-size: 12px; opacity: .6; margin: 12px auto 0; text-align: center; max-width: min(780px, 100%); }
    .thinking-indicator { display: inline-block; width: 18px; height: 18px; border: 2px solid #4f46e5; border-radius: 50%; border-top-color: transparent; animation: spin 1s ease-in-out infinite; margin-right: 10px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    @media (max-width: 1180px) {
      #sidebar { width: 240px; }
      #chat-container { padding: 28px 22px; }
      #output-wrapper { width: min(700px, 100%); }
    }
    @media (max-width: 980px) {
      #sidebar { width: 220px; }
      #chat-container { padding: 24px 18px; }
      #output-wrapper { width: min(640px, 100%); }
    }
    @media (max-width: 900px) {
      body { flex-direction: column; }
      #sidebar { width: 100%; border-right: none; border-bottom: 1px solid #292a33; max-height: 45vh; overflow-y: auto; }
      #history-wrapper { max-height: 30vh; }
      #main { width: 100%; }
      #chat-container { padding: 20px 16px; }
      #output-wrapper { width: 100%; }
      #input-area { padding: 18px 16px 22px; }
      .bar { flex-direction: column; gap: 12px; }
      button { width: 100%; }
      input[type=text] { padding: 14px; }
    }
    @media (max-width: 600px) {
      .message { width: 100%; align-self: stretch; }
      .user { align-self: stretch; }
    }
    .message { display: flex; width: 100%; padding: 0; margin: 0; }
    .message.assistant { justify-content: flex-start; }
    .message.user { justify-content: flex-end; }
    .bubble { display: flex; flex-direction: column; gap: 12px; padding: 18px 20px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.18); background: #1f2025; color: #e5e7f0; border: 1px solid rgba(255,255,255,0.04); width: min(720px, 100%); box-sizing: border-box; }
    .message.assistant .bubble { margin-right: auto; }
    .bubble.user { background: linear-gradient(135deg, rgba(88,89,221,0.95), rgba(56,57,143,0.95)); color: #f7f8ff; border: none; box-shadow: 0 14px 28px rgba(88,89,221,0.25); max-width: min(520px, 85%); margin-left: auto; }
    .message.user .bubble { margin-left: auto; }
    .message.user .markdown-body { color: inherit; }
    .status { opacity: .85; font-size: 14px; display: flex; align-items: center; gap: 8px; padding: 6px 0; }
    details.reasoning { background: #15151a; border: 1px solid #2a2a2d; border-radius: 10px; padding: 10px 12px; margin: 8px 0 10px; }
    details.reasoning summary { list-style: none; cursor: pointer; display: flex; align-items: center; gap: 8px; user-select: none; }
    details.reasoning summary::before { content: '▸'; transition: transform .15s ease; }
    details.reasoning[open] summary::before { transform: rotate(90deg); }
    .reasoning-body { margin-top: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12.5px; line-height: 1.6; opacity: .95; }
    .reasoning-meta { font-size: 12px; color: #a6a9b0; display: flex; flex-direction: column; gap: 4px; }
    .reasoning-thought { margin-top: 8px; background: #111118; border: 1px solid #2d2d32; border-radius: 8px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12.5px; line-height: 1.6; color: #d9dce4; white-space: pre-wrap; }
    .cot-box { margin: 0 0 12px 0; background: #15151a; border: 1px solid #2d2d32; border-radius: 10px; padding: 10px 12px; width: 100%; display: block; }
    .cot-box summary { font-weight: 600; }
    .assistant-answer { margin-top: 12px; }
    .assistant-answer.solo { margin-top: 0; }
    .inline-code { background: rgba(148,163,184,0.18); border: 1px solid rgba(148,163,184,0.25); border-radius: 6px; padding: 2px 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; }
    .md-h1, .md-h2, .md-h3, .md-h4, .md-h5, .md-h6 { font-weight: 700; margin-top: 12px; }
    .md-h1 { font-size: 22px; }
    .md-h2 { font-size: 20px; }
    .md-h3 { font-size: 18px; }
    .md-h4 { font-size: 16px; }
    .md-h5 { font-size: 15px; }
    .md-h6 { font-size: 14px; }
    .md-paragraph { margin: 8px 0; line-height: 1.65; color: #e1e1e6; }
    .md-list { margin: 8px 0 8px 18px; padding-left: 18px; line-height: 1.65; }
    .md-list li { margin: 4px 0; }
    .markdown-body { display: flex; flex-direction: column; gap: 12px; width: 100%; }
    #knowledge-panel { border-top: 1px solid #292a33; padding: 16px 18px 22px; background: #14151a; margin-top: auto; }
    .knowledge-title { font-size: 13px; text-transform: uppercase; letter-spacing: 0.08em; opacity: .75; margin-bottom: 8px; }
    .knowledge-topics { display: flex; flex-direction: column; gap: 6px; }
    .knowledge-topic { display: flex; justify-content: space-between; font-size: 13px; color: #d1d5db; background: #2a2b32; border-radius: 8px; padding: 6px 10px; }
    .knowledge-topic span.count { font-size: 12px; opacity: .7; }
    .knowledge-empty { font-size: 12px; opacity: .6; }
    .knowledge-subtitle { font-size: 11px; letter-spacing: 0.08em; text-transform: uppercase; margin-top: 14px; opacity: .55; }    .knowledge-edges { margin-top: 12px; font-size: 12px; color: #aab0bc; display: flex; flex-direction: column; gap: 4px; }
    .knowledge-edge strong { color: #d1d5db; }
    .code-block { position: relative; background: #111118; border: 1px solid #2d2d32; border-radius: 12px; margin: 14px 0; overflow: hidden; }
    .code-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; border-bottom: 1px solid #272832; background: rgba(54,55,66,0.55); font-size: 11px; letter-spacing: 0.12em; text-transform: uppercase; color: #a3aed0; }
    .code-lang { font-weight: 600; color: #cbd5f5; }
    .code-body { padding: 14px; overflow-x: auto; }
    .code-body pre { margin: 0; white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 13px; line-height: 1.68; color: #f1f5f9; }
    .code-body code { display: block; }
    .copy-btn { background: rgba(79,70,229,0.18); color: #c7d2fe; border: 1px solid rgba(99,102,241,0.35); border-radius: 6px; padding: 3px 10px; font-size: 11px; cursor: pointer; }
    .copy-btn:hover { background: rgba(79,70,229,0.32); color: #fff; }
  </style>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Script loaded');
      const sidebar = document.getElementById('sidebar');
      const historyWrapper = document.getElementById('history-wrapper');
      const chatHistory = document.getElementById('chat-history');
      const newChatBtn = document.getElementById('new-chat');
      const saveChatBtn = document.getElementById('save-chat');
      const input = document.getElementById('query');
      const sendBtn = document.getElementById('submitBtn');
      const output = document.getElementById('output');
      const chatContainer = document.getElementById('chat-container');

      const knowledgePanel = document.createElement('div');
      knowledgePanel.id = 'knowledge-panel';
      const knowledgeTitle = document.createElement('div');
      knowledgeTitle.className = 'knowledge-title';
      knowledgeTitle.textContent = 'Knowledge Graph';
      const knowledgeTopics = document.createElement('div');
      knowledgeTopics.className = 'knowledge-topics';
      const knowledgeEdges = document.createElement('div');
      knowledgeEdges.className = 'knowledge-edges';
      knowledgePanel.appendChild(knowledgeTitle);
      knowledgePanel.appendChild(knowledgeTopics);
      knowledgePanel.appendChild(knowledgeEdges);
      if (historyWrapper && historyWrapper.parentElement) {
        historyWrapper.parentElement.insertBefore(knowledgePanel, historyWrapper.nextSibling);
      } else {
        sidebar.appendChild(knowledgePanel);
      }

      // Stop/Cancel button
      const stopBtn = document.createElement('button');
      stopBtn.id = 'stopBtn';
      stopBtn.textContent = 'Cancel';
      stopBtn.disabled = true;
      document.querySelector('.bar').appendChild(stopBtn);

      let currentChatId = null;
      let chats = JSON.parse(localStorage.getItem('chatHistory')) || [];
      let isStreaming = false;
      let currentRid = null;

      function renderHistory() {
        chatHistory.innerHTML = '';
        chats.forEach(chat => {
          const item = document.createElement('div');
          item.className = 'chat-item' + (chat.id === currentChatId ? ' active' : '');
          item.onclick = () => loadChat(chat.id);
          const title = document.createElement('div');
          title.className = 'chat-title';
          title.textContent = chat.title;
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'chat-delete';
          deleteBtn.type = 'button';
          deleteBtn.textContent = '×';
          deleteBtn.title = 'Delete chat';
          deleteBtn.onclick = (ev) => {
            ev.stopPropagation();
            deleteChat(chat.id);
          };
          item.appendChild(title);
          item.appendChild(deleteBtn);
          chatHistory.appendChild(item);
        });
      }

      async function saveCurrentChat() {
        if (!currentChatId) {
          alert('Select a chat to save.');
          return;
        }
        const chat = chats.find(c => c.id === currentChatId);
        if (!chat || !Array.isArray(chat.messages) || chat.messages.length === 0) {
          alert('Nothing to save yet.');
          return;
        }
        if (saveChatBtn.classList.contains('saving')) return;
        const originalLabel = saveChatBtn.textContent;
        saveChatBtn.classList.add('saving');
        saveChatBtn.textContent = 'Saving…';
        try {
          const resp = await fetch('/chats', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ title: chat.title, messages: chat.messages })
          });
          if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(err.error || 'Failed to save chat');
          }
          saveChatBtn.textContent = 'Saved!';
          refreshKnowledgeGraph();
          setTimeout(() => {
            saveChatBtn.textContent = originalLabel;
            saveChatBtn.classList.remove('saving');
          }, 1200);
        } catch (error) {
          console.error(error);
          alert(error.message || 'Unable to save chat.');
          saveChatBtn.textContent = originalLabel;
          saveChatBtn.classList.remove('saving');
        }
      }

      function deleteChat(chatId) {
        const index = chats.findIndex(c => c.id === chatId);
        if (index === -1) return;
        const wasCurrent = chatId === currentChatId;
        chats.splice(index, 1);
        localStorage.setItem('chatHistory', JSON.stringify(chats));
        if (wasCurrent) {
          output.innerHTML = '';
          if (chats.length > 0) {
            currentChatId = chats[0].id;
            loadChat(currentChatId);
          } else {
            currentChatId = null;
            renderHistory();
          }
        } else {
          renderHistory();
        }
        refreshKnowledgeGraph();
      }

      async function refreshKnowledgeGraph() {
        try {
          const resp = await fetch('/knowledge');
          if (!resp.ok) return;
          const data = await resp.json();
          renderKnowledge(data);
        } catch (error) {
          console.warn('Knowledge graph refresh failed', error);
        }
      }

      function renderKnowledge(data) {
        knowledgeTopics.innerHTML = '';
        knowledgeEdges.innerHTML = '';
        if (!data || !Array.isArray(data.nodes) || data.nodes.length === 0) {
          knowledgeTopics.innerHTML = '<div class="knowledge-empty">No topics yet.</div>';
          return;
        }
        data.nodes.slice(0, 12).forEach(item => {
          const row = document.createElement('div');
          row.className = 'knowledge-topic';
          const label = document.createElement('span');
          label.textContent = item.id;
          const count = document.createElement('span');
          count.className = 'count';
          count.textContent = item.count;
          row.appendChild(label);
          row.appendChild(count);
          knowledgeTopics.appendChild(row);
        });
        if (Array.isArray(data.edges) && data.edges.length > 0) {
          const heading = document.createElement('div');
          heading.className = 'knowledge-subtitle';
          heading.textContent = 'Connections';
          knowledgeEdges.appendChild(heading);
          const topEdges = data.edges.slice(0, 6);
          topEdges.forEach(edge => {
            const row = document.createElement('div');
            row.className = 'knowledge-edge';
            row.innerHTML = `<strong>${edge.source}</strong> ↔ <strong>${edge.target}</strong> <span class="count">(${edge.count})</span>`;
            knowledgeEdges.appendChild(row);
          });
        }
      }

      function addNewChat() {
        const title = prompt('New chat title:') || 'New Chat';
        const chatId = Date.now().toString();
        chats.unshift({id: chatId, title: title, messages: []});
        currentChatId = chatId;
        localStorage.setItem('chatHistory', JSON.stringify(chats));
        renderHistory();
        output.innerHTML = '';
        scrollToBottom();
      }

      function loadChat(chatId) {
        const chat = chats.find(c => c.id === chatId);
        if (!chat) return;
        currentChatId = chatId;
        output.innerHTML = '';
        chat.messages.forEach(msg => {
          if (msg.role === 'assistant') {
            appendAssistantMessage(msg.content || '', msg.reasoning || '');
          } else {
            appendBubble(msg.role, msg.content);
          }
        });
        renderHistory();
        scrollToBottom();
      }

      function saveMessage(role, content, reasoning = '') {
        if (!currentChatId) return;
        const chat = chats.find(c => c.id === currentChatId);
        if (!chat) return;
        const entry = {role, content};
        if (role === 'assistant' && reasoning) {
          entry.reasoning = reasoning;
        }
        chat.messages.push(entry);
        localStorage.setItem('chatHistory', JSON.stringify(chats));
      }

      function appendBubble(role, content) {
        const row = document.createElement('div');
        row.className = `message ${role}`;
        const bubble = document.createElement('div');
        bubble.className = `bubble ${role}`;
        const rendered = renderMarkdown(typeof content === 'string' ? content : String(content ?? ''));
        bubble.appendChild(rendered);
        row.appendChild(bubble);
        output.appendChild(row);
        scrollToBottom();
        return bubble;
      }

      function scrollToBottom() {
        chatContainer.scrollTop = chatContainer.scrollHeight;
      }

      function stripThinkTags(s) {
        if (!s) return '';
        const open = '<think>';
        const close = '</think>';
        let cursor = 0;
        let result = '';
        const lower = s.toLowerCase();
        while (cursor < s.length) {
          const start = lower.indexOf(open, cursor);
          if (start === -1) {
            result += s.slice(cursor);
            break;
          }
          result += s.slice(cursor, start);
          const end = lower.indexOf(close, start + open.length);
          if (end === -1) {
            result += s.slice(start);
            break;
          }
          cursor = end + close.length;
        }
        return result;
      }

      function escapeHtml(str) {
        return (str || '').replace(/[&<>"']/g, ch => ({'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'}[ch]));
      }

      function renderMarkdown(text) {
        const container = document.createElement('div');
        container.className = 'markdown-body';
        const raw = (text ?? '').toString();
        if (!raw.trim()) return container;
        const regex = /```([A-Za-z0-9_#+-]*)\r?\n([\s\S]*?)```/g;
        let lastIndex = 0;
        let match;
        while ((match = regex.exec(raw)) !== null) {
          const before = raw.slice(lastIndex, match.index);
          renderTextSegments(container, raw.slice(lastIndex, match.index));
          const lang = (match[1] || '').trim();
          let codeRaw = match[2];
          codeRaw = codeRaw.replace(/^\r?\n/, '').replace(/\r?\n$/, '');
          const codeBlock = buildCodeBlock(codeRaw, lang);
          container.appendChild(codeBlock);
          lastIndex = regex.lastIndex;
        }
        const remainder = raw.slice(lastIndex);
        renderTextSegments(container, remainder);
        if (!container.childNodes.length && raw.trim()) {
          renderTextSegments(container, raw);
        }
        return container;
      }

      function isLikelyCodeBlock(text) {
        if (!text) return false;
        const normalized = text.replace(/\r?\n/g, '\n').trim();
        if (!normalized) return false;
        const lines = normalized.split('\n');
        if (lines.length <= 1) return false;
        const keywordPattern = /^(?:def\s|class\s|if\s|if\(|for\s|for\(|while\s|while\(|switch\s|case\s|return(?:\s|;)|public\s|private\s|protected\s|import\s|from\s|try\s|catch\s|const\s|let\s|var\s|async\s|await\s|function\s|function\(|#include\s)/i;
        const keywordLines = lines.filter(line => keywordPattern.test(line.trim()));
        if (keywordLines.length >= 2) {
          return true;
        }
        const punctuationLines = lines.filter(line => /[{};=<>\[\]\(\)]/.test(line));
        if (punctuationLines.length >= Math.max(2, Math.ceil(lines.length * 0.6))) {
          return true;
        }
        const indentedLines = lines.filter(line => /^\s{4,}|\t/.test(line));
        return indentedLines.length >= Math.max(2, Math.ceil(lines.length * 0.6));
      }

      function renderTextSegments(parent, segment) {
        if (!segment) return;
        let normalized = segment.replace(/\\r?\\n/g, '\\n');
        normalized = normalized
          .replace(/([^\\n])(\\d+\\.\\s+)/g, (_, a, b) => `${a}\n${b}`)
          .replace(/([^\\n])([-*+]\\s+)/g, (_, a, b) => `${a}\n${b}`)
          .replace(/\\n{3,}/g, '\n\n');

        const lines = normalized.split('\\n');
        let paragraphBuffer = [];
        let listEl = null;
        let listType = null;

        const flushParagraph = () => {
          if (!paragraphBuffer.length) return;
          const rawJoined = paragraphBuffer.join('\\n');
          if (isLikelyCodeBlock(rawJoined)) {
            const codeBlock = buildCodeBlock(rawJoined.replace(/^[\s\n]+|[\s\n]+$/g, ''), '');
            parent.appendChild(codeBlock);
          } else {
            const paragraph = document.createElement('div');
            paragraph.className = 'md-paragraph';
            const inlineText = paragraphBuffer.map(line => line.trim()).join('\\n');
            paragraph.innerHTML = formatInline(inlineText);
            parent.appendChild(paragraph);
          }
          paragraphBuffer = [];
        };

        const flushList = () => {
          if (!listEl) return;
          parent.appendChild(listEl);
          listEl = null;
          listType = null;
        };

        const startList = (type) => {
          if (listType === type && listEl) return;
          flushList();
          listEl = document.createElement(type === 'ordered' ? 'ol' : 'ul');
          listEl.className = 'md-list';
          listType = type;
        };

        lines.forEach(rawLine => {
          const line = rawLine.trim();
          if (!line) {
            flushParagraph();
            flushList();
            return;
          }
          const headingMatch = line.match(/^#{1,6}\s+(.*)$/);
          if (headingMatch) {
            flushParagraph();
            flushList();
            const level = Math.min(line.match(/^#+/)[0].length, 6);
            const heading = document.createElement('div');
            heading.className = 'md-h' + level;
            heading.innerHTML = formatInline(headingMatch[1]);
            parent.appendChild(heading);
            return;
          }
          const orderedMatch = line.match(/^(\d+)\.\s+(.*)$/);
          if (orderedMatch) {
            flushParagraph();
            startList('ordered');
            const li = document.createElement('li');
            li.innerHTML = formatInline(orderedMatch[2]);
            listEl.appendChild(li);
            return;
          }
          const unorderedMatch = line.match(/^[-*+]\s+(.*)$/);
          if (unorderedMatch) {
            flushParagraph();
            startList('unordered');
            const li = document.createElement('li');
            li.innerHTML = formatInline(unorderedMatch[1]);
            listEl.appendChild(li);
            return;
          }
          flushList();
          paragraphBuffer.push(rawLine);
        });

        flushParagraph();
        flushList();
      }
      function formatInline(str) {
        if (!str) return '';
        let html = escapeHtml(str);
        html = html.replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>');
        html = html.replace(/\\*([^*]+)\\*/g, '<em>$1</em>');
        html = html.replace(/`([^`]+)`/g, '<code class=\"inline-code\">$1</code>');
        html = html.replace(/\\n/g, '<br>');
        return html;
      }
      function buildCodeBlock(codeText, language) {
        const wrapper = document.createElement('div');
        wrapper.className = 'code-block';
        const header = document.createElement('div');
        header.className = 'code-header';
        const langLabel = document.createElement('span');
        langLabel.className = 'code-lang';
        langLabel.textContent = (language || 'code').toUpperCase();
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'copy-btn';
        btn.textContent = 'Copy';
        btn.addEventListener('click', async () => {
          try {
            if (navigator?.clipboard?.writeText) {
              await navigator.clipboard.writeText(codeText);
            } else {
              copyTextFallback(codeText);
            }
            const original = btn.textContent;
            btn.textContent = 'Copied!';
            setTimeout(() => { btn.textContent = original; }, 1200);
          } catch (_err) {
            btn.textContent = 'Failed';
            setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
          }
        });
        const body = document.createElement('div');
        body.className = 'code-body';
        const pre = document.createElement('pre');
        const code = document.createElement('code');
        if (language) code.setAttribute('data-lang', language);
        code.textContent = codeText;
        pre.appendChild(code);
        header.appendChild(langLabel);
        header.appendChild(btn);
        body.appendChild(pre);
        wrapper.appendChild(header);
        wrapper.appendChild(body);
        return wrapper;
      }

      function copyTextFallback(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        try {
          document.execCommand('copy');
        } finally {
          document.body.removeChild(textarea);
        }
      }

      function createCotDetails(reasoningText, metaLines = []) {
        const hasMeta = Array.isArray(metaLines) && metaLines.some(line => line && line.trim());
        const hasThought = Boolean(reasoningText && reasoningText.trim());
        if (!hasThought && !hasMeta) return null;
        const details = document.createElement('details');
        details.className = 'reasoning cot-box';
        details.open = false;
        const summary = document.createElement('summary');
        summary.innerHTML = '<span>Chain of Thought</span>';
        const body = document.createElement('div');
        body.className = 'reasoning-body';
        const meta = document.createElement('div');
        meta.className = 'reasoning-meta';
        if (hasMeta) {
          (metaLines || []).forEach(line => {
            if (!line) return;
            const div = document.createElement('div');
            div.textContent = line;
            meta.appendChild(div);
          });
          body.appendChild(meta);
        }
        if (hasThought) {
          const thought = document.createElement('pre');
          thought.className = 'reasoning-thought';
          thought.textContent = reasoningText.trim();
          body.appendChild(thought);
        }
        details.appendChild(summary);
        details.appendChild(body);
        return details;
      }

      function appendAssistantMessage(answerText, reasoningText, cotElement) {
        const row = document.createElement('div');
        row.className = 'message assistant';
        const bubble = document.createElement('div');
        bubble.className = 'bubble assistant';
        const hasReasoning = Boolean(reasoningText || cotElement);
        if (cotElement) {
          bubble.appendChild(cotElement);
        } else if (reasoningText) {
          const cot = createCotDetails(reasoningText);
          if (cot) bubble.appendChild(cot);
        }
        if (answerText) {
          const answerWrap = document.createElement('div');
          answerWrap.className = hasReasoning ? 'assistant-answer' : 'assistant-answer solo';
          const rendered = renderMarkdown(typeof answerText === 'string' ? answerText : String(answerText ?? ''));
          answerWrap.appendChild(rendered);
          bubble.appendChild(answerWrap);
        } else if (!hasReasoning) {
          const fallback = document.createElement('div');
          fallback.className = 'assistant-answer';
          fallback.textContent = 'No response received.';
          bubble.appendChild(fallback);
        }
        row.appendChild(bubble);
        output.appendChild(row);
        scrollToBottom();
        return bubble;
      }

      function newRid() {
        return (crypto?.randomUUID?.() || ('rid-' + Date.now() + '-' + Math.random().toString(16).slice(2)));
      }

      function buildReasoningWidget() {
        const details = document.createElement('details');
        details.className = 'reasoning';
        details.open = false; // Closed by default
        const summary = document.createElement('summary');
        summary.innerHTML = '<span class="thinking-indicator"></span><span>Chain of Thought</span>';
        const body = document.createElement('div');
        body.className = 'reasoning-body';
        const meta = document.createElement('div');
        meta.className = 'reasoning-meta';
        const thought = document.createElement('pre');
        thought.className = 'reasoning-thought';
        body.appendChild(meta);
        body.appendChild(thought);
        details.appendChild(summary);
        details.appendChild(body);
        return { details, summary, body, meta, thought };
      }

      function appendReasoningLine(container, text) {
        if (!text) return;
        const p = document.createElement('div');
        p.textContent = text;
        container.appendChild(p);
      }

      function send() {
        console.log('send called');
        const q = input.value.trim();
        if (!q || !currentChatId) {
          output.textContent = 'Enter a query and select a chat.';
          return;
        }
        if (q.length > {{ max_query_length }}) {
          output.textContent = 'Query too long.';
          return;
        }
        if (isStreaming) return;

        // User bubble
        appendBubble('user', q);
        saveMessage('user', q);
        input.value = '';
        scrollToBottom();

        // Status line
        const status = document.createElement('div');
        status.className = 'status';
        status.innerHTML = '<span class="thinking-indicator"></span>Generating…';

        // Reasoning panel
        const reasonUI = buildReasoningWidget();

        // Container to keep thinking UI grouped
        const thinkingRow = document.createElement('div');
        thinkingRow.className = 'message assistant streaming';
        const thinkingShell = document.createElement('div');
        thinkingShell.className = 'bubble assistant streaming';
        thinkingShell.appendChild(status);
        thinkingShell.appendChild(reasonUI.details);
        thinkingRow.appendChild(thinkingShell);
        output.appendChild(thinkingRow);
        let thinkingContainer = thinkingRow;

        let finalAnswer = '';
        let thinkMode = 'answer';
        let pendingText = '';
        let rawStream = '';
        const NEWLINE_CHAR = String.fromCharCode(10);
        const ESCAPED_NEWLINE = '\\n';
        const THINK_OPEN = '<Think>';
        const THINK_CLOSE = '</Think>';
        const OPEN_LEN = THINK_OPEN.length;
        const CLOSE_LEN = THINK_CLOSE.length;
        const thinkingHolder = reasonUI.thought;
        thinkingHolder.textContent = '';
        function appendThinking(text) {
          if (!text) return;
          if (text === ESCAPED_NEWLINE) {
            thinkingHolder.textContent += NEWLINE_CHAR;
            return;
          }
          thinkingHolder.textContent += text;
        }
        function processChunk(text) {
          rawStream += text;
          pendingText += text;
          while (pendingText) {
            if (thinkMode === 'think') {
              const closeIdx = pendingText.indexOf(THINK_CLOSE);
              if (closeIdx === -1) {
                const safeLength = Math.max(0, pendingText.length - (CLOSE_LEN - 1));
                if (safeLength === 0) break;
                appendThinking(pendingText.slice(0, safeLength));
                pendingText = pendingText.slice(safeLength);
                break;
              }
              appendThinking(pendingText.slice(0, closeIdx));
              appendThinking(ESCAPED_NEWLINE);
              pendingText = pendingText.slice(closeIdx + CLOSE_LEN);
              thinkMode = 'answer';
              continue;
            }
            const openIdx = pendingText.indexOf(THINK_OPEN);
            if (openIdx === -1) {
              const safeLength = Math.max(0, pendingText.length - (OPEN_LEN - 1));
              if (safeLength === 0) break;
              finalAnswer += pendingText.slice(0, safeLength);
              pendingText = pendingText.slice(safeLength);
              break;
            }
            finalAnswer += pendingText.slice(0, openIdx);
            pendingText = pendingText.slice(openIdx + OPEN_LEN);
            thinkMode = 'think';
          }
        }
        function flushPending() {
          if (!pendingText) return;
          if (thinkMode === 'think') {
            appendThinking(pendingText);
            appendThinking(ESCAPED_NEWLINE);
          } else {
            finalAnswer += pendingText;
          }
          pendingText = '';
        }
        currentRid = newRid();

        if (window.es) window.es.close();
        window.es = new EventSource('/stream?query=' + encodeURIComponent(q) + '&rid=' + encodeURIComponent(currentRid));
        isStreaming = true;
        sendBtn.disabled = true;
        stopBtn.disabled = false;
        input.disabled = true;

        window.es.onmessage = function(e) {
          console.log('Received: ' + e.data);
          const data = e.data || '';
          if (data === 'DONE') {
            flushPending();
            const cleanAnswer = stripThinkTags(finalAnswer).trim();
            const fallbackAnswer = finalAnswer.trim();
            const rawClean = stripThinkTags(rawStream).trim();
            const rawFallback = rawStream.trim();
            const answerForDisplay = cleanAnswer || fallbackAnswer || rawClean || rawFallback;
            if (reasonUI.details.parentElement) {
              reasonUI.details.parentElement.removeChild(reasonUI.details);
            }
            const metaLines = Array.from(reasonUI.meta.children || []).map(node => (node.textContent || '').trim()).filter(Boolean);
            const metaText = metaLines.join('\\n');
            const reasoningText = (thinkingHolder.textContent || '').trim();
            const storedReasoning = [...metaLines, reasoningText].filter(Boolean).join('\\n');
            const hasReasoning = storedReasoning.length > 0;
            if (hasReasoning) {
              const spinner = reasonUI.summary.querySelector('.thinking-indicator');
              if (spinner) spinner.remove();
              reasonUI.summary.innerHTML = '<span>Chain of Thought</span>';
              reasonUI.details.classList.add('cot-box');
              reasonUI.details.open = false;
            } else {
              reasonUI.details.remove();
            }
            const cotElement = hasReasoning ? reasonUI.details : null;
            const assistantDiv = appendAssistantMessage(answerForDisplay, reasoningText, cotElement);
            if (answerForDisplay || storedReasoning) {
              saveMessage('assistant', answerForDisplay, storedReasoning);
            }
            if (thinkingContainer && thinkingContainer.parentElement) {
              thinkingContainer.remove();
            }
            if (!cotElement && hasReasoning) {
              const fallbackCot = createCotDetails(reasoningText, metaLines);
              if (fallbackCot && assistantDiv) {
                assistantDiv.insertBefore(fallbackCot, assistantDiv.firstChild);
              }
            }
            refreshKnowledgeGraph();
            cleanup('');
            scrollToBottom();
            return;
          }
          if (data.startsWith('META|')) {
            try {
              const meta = JSON.parse(data.slice(5));
              if (meta.source === 'memory') {
                appendReasoningLine(reasonUI.meta, meta.status === 'hit' ? 'Memory: hit' : 'Memory: miss');
              }
              if (meta.cycle && meta.status === 'generating') {
                appendReasoningLine(reasonUI.meta, 'Cycle ' + meta.cycle + ': generating…');
              }
              if (meta.cycle && meta.status === 'generated') {
                appendReasoningLine(reasonUI.meta, 'Cycle ' + meta.cycle + ': generated (' + (meta.tokens || 0) + ' tokens)');
              }
              if (meta.action === 'search') {
                appendReasoningLine(reasonUI.meta, 'Search → "' + (meta.query || '') + '"');
              }
              if (meta.action === 'search_failed') {
                appendReasoningLine(reasonUI.meta, 'Search failed.');
              }
              if (meta.action === 'search_empty') {
                appendReasoningLine(reasonUI.meta, 'Search returned no results.');
              }
              if (meta.status === 'finalizing') {
                appendReasoningLine(reasonUI.meta, 'Finalizing answer…');
              }
            } catch (_e) {}
            return;
          }
          processChunk(data);
          scrollToBottom();
        };

        window.es.onerror = function() {
          console.log('EventSource error');
          cleanup('Connection lost.');
          scrollToBottom();
        };

        async function cancelStream() {
          if (!isStreaming) return;
          try {
            await fetch('/cancel?rid=' + encodeURIComponent(currentRid), { method: 'POST' });
          } catch (_e) {}
          if (window.es) window.es.close();
          cleanup('Cancelled.');
          scrollToBottom();
        }

        stopBtn.onclick = cancelStream;
        document.addEventListener('keydown', function onEsc(ev) {
          if (ev.key === 'Escape') cancelStream();
        });

        function cleanup(msg) {
          if (window.es) window.es.close();
          isStreaming = false;
          sendBtn.disabled = false;
          stopBtn.disabled = true;
          input.disabled = false;
          currentRid = null;
          if (thinkingContainer && thinkingContainer.parentElement) {
            thinkingContainer.remove();
          }
          thinkingContainer = null;
          if (msg) {
            status.textContent = msg;
            setTimeout(() => status.remove(), 3000); // Remove status after 3s
          } else {
            status.remove();
          }
          thinkMode = 'answer';
          pendingText = '';
          finalAnswer = '';
          rawStream = '';
        }
      }

      newChatBtn.onclick = addNewChat;
      saveChatBtn.addEventListener('click', saveCurrentChat);
      sendBtn.addEventListener('click', send);
      input.addEventListener('keypress', function(e) { 
        if (e.key === 'Enter') {
          console.log('Enter key pressed');
          send();
        }
      });

      renderHistory();
      if (chats.length > 0) loadChat(chats[0].id);
      refreshKnowledgeGraph();
    });
  
</script>
</head>
<body>
  <div id="sidebar">
    <div id="sidebar-header">
      <button id="new-chat">+ New Chat</button>
      <button id="save-chat">Save</button>
    </div>
    <div id="history-wrapper">
      <div id="chat-history"></div>
    </div>
  </div>
  <div id="main">
    <div id="chat-container">
      <div id="output-wrapper">
        <div id="output"></div>
      </div>
    </div>
    <div id="input-area">
      <div class="bar">
        <input id="query" type="text" placeholder="Ask anything...">
        <button id="submitBtn">Send</button>
      </div>
      <div class="note">This UI shows raw chain-of-thought and final answer.</div>
    </div>
  </div>
</body>
</html>
