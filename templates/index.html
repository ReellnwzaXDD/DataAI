<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AI Chat Assistant · Ant Design</title>
    <!-- Ant Design v4 (Dark theme) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/antd/4.24.16/antd.dark.min.css" integrity="sha512-qkQw8xC3l4LwQ++BP7m7oY6ZlWkD0kqVoJVx2wymDm8qszAtQd7FQBx8mZQH8l0aESxW9g1aVXb/0q3+uemXqA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
      :root { color-scheme: dark; }
      html, body, #root { height: 100%; }
      body { margin: 0; }
      .app-layout { height: 100%; }
      .chat-content { height: 100%; display: flex; flex-direction: column; }
      .messages { flex: 1; overflow-y: auto; padding: 16px 16px 24px; background: #0f1115; }
      .message-row { display: flex; gap: 12px; margin-bottom: 12px; }
      .message-row.user { justify-content: flex-end; }
      .message-bubble { max-width: 72%; padding: 12px 14px; border-radius: 10px; white-space: pre-wrap; word-break: break-word; }
      .message-bubble.assistant { background: #1f2330; border: 1px solid #30364a; }
      .message-bubble.user { background: #2b3562; border: 1px solid #3a4a82; }
      .input-bar { border-top: 1px solid rgba(255,255,255,0.08); background: #0f1115; padding: 12px 16px; }
      .sidebar-title { color: #e6e6e6; font-weight: 600; margin-bottom: 8px; }
      .sidebar { border-right: 1px solid rgba(255,255,255,0.08); }
      .session-item { cursor: pointer; padding: 6px 8px; border-radius: 6px; }
      .session-item.active { background: rgba(255,255,255,0.08); }
      .reasoning-panel pre { margin: 0; white-space: pre-wrap; }
      .top-header { display: flex; align-items: center; justify-content: space-between; padding: 0 8px; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script>
      window.MAX_QUERY_LENGTH = {{ max_query_length|tojson }};
    </script>
    <!-- React 18 UMD -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- AntD v4 UMD -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/antd/4.24.16/antd.min.js" integrity="sha512-P9l4cfpoHQr2wT+1sH9S+X2NgkgK5uS4V0DoIh5oRr7d8sJ2rihxA7z12C3h2yY4QDCz11qFQ5uQzF87UJEH7A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- Babel for JSX (dev convenience) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      {% raw %}
      const { useState, useEffect, useRef, useMemo } = React;
      const {
        Layout, Button, Input, List, Typography, Space, Modal,
        message: antdMessage, Divider, Popconfirm, Avatar, Collapse,
      } = antd;
      const { Header, Sider, Content } = Layout;
      const { Text } = Typography;
      const { TextArea } = Input;
      const { Panel } = Collapse;

      // Utilities
      function uuid() {
        return (crypto?.randomUUID?.() || ('id-' + Date.now() + '-' + Math.random().toString(16).slice(2)));
      }
      function stripThinkTags(s) {
        return (s || '').replace(/<Think>[\s\S]*?<\/Think>/gi, '');
      }
      function extractReasoning(s) {
        const m = [...(s || '').matchAll(/<Think>([\s\S]*?)<\/Think>/gi)];
        return m.map(x => (x[1] || '').trim()).filter(Boolean).join('\n');
      }

      function loadChats() {
        try {
          return JSON.parse(localStorage.getItem('chatHistory') || '[]');
        } catch (_) { return []; }
      }
      function saveChats(chats) {
        localStorage.setItem('chatHistory', JSON.stringify(chats));
      }

      function Messages({ items }) {
        const scRef = useRef(null);
        useEffect(() => {
          if (scRef.current) scRef.current.scrollTop = scRef.current.scrollHeight;
        }, [items]);
        return (
          <div className="messages" ref={scRef}>
            {items.map((m, idx) => (
              <div className={"message-row " + (m.role === 'user' ? 'user' : 'assistant')} key={idx}>
                {m.role === 'assistant' && <Avatar>AI</Avatar>}
                <div className={"message-bubble " + (m.role === 'user' ? 'user' : 'assistant')}>
                  <div style={{ whiteSpace: 'pre-wrap' }}>{m.content}</div>
                  {m.reasoning && (
                    <div style={{ marginTop: 8 }} className="reasoning-panel">
                      <Collapse ghost>
                        <Panel header="Reasoning" key="r">
                          <pre>{m.reasoning}</pre>
                        </Panel>
                      </Collapse>
                    </div>
                  )}
                </div>
                {m.role === 'user' && <Avatar>U</Avatar>}
              </div>
            ))}
          </div>
        );
      }

      function App() {
        const [chats, setChats] = useState(loadChats());
        const [currentId, setCurrentId] = useState(chats[0]?.id || null);
        const [input, setInput] = useState('');
        const [streaming, setStreaming] = useState(false);
        const [rid, setRid] = useState(null);

        const current = useMemo(() => chats.find(c => c.id === currentId) || null, [chats, currentId]);
        useEffect(() => saveChats(chats), [chats]);

        function newChat() {
          const id = uuid();
          const chat = { id, title: 'New Chat', messages: [], updated: Date.now() };
          setChats([chat, ...chats]);
          setCurrentId(id);
        }
        function selectChat(id) { setCurrentId(id); }
        function deleteChat(id) {
          Modal.confirm({
            title: 'Delete this chat?',
            okType: 'danger',
            onOk: () => {
              const nx = chats.filter(c => c.id !== id);
              setChats(nx);
              if (id === currentId) setCurrentId(nx[0]?.id || null);
            },
          });
        }
        function setTitleFromFirstUser() {
          setChats(prev => prev.map(c => {
            if (c.id !== currentId) return c;
            if (!c.title || c.title === 'New Chat') {
              const first = c.messages.find(m => m.role === 'user');
              if (first) {
                const line = first.content.split('\n')[0].slice(0, 48) || 'Conversation';
                return { ...c, title: line };
              }
            }
            return c;
          }));
        }
        async function saveCurrentChat() {
          if (!current || current.messages.length === 0) {
            antd.message?.info?.('Nothing to save.') || antdMessage.info('Nothing to save.');
            return;
          }
          try {
            const res = await fetch('/chats', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ title: current.title, messages: current.messages }),
            });
            if (!res.ok) throw new Error('Save failed');
            antdMessage.success('Saved to server');
          } catch (e) {
            antdMessage.error('Save failed');
          }
        }
        function newRid() { return uuid(); }
        async function cancel() {
          if (!streaming || !rid) return;
          try { await fetch('/cancel?rid=' + encodeURIComponent(rid), { method: 'POST' }); } catch (_) {}
          setStreaming(false); setRid(null);
          antdMessage.info('Cancelled');
        }
        async function send() {
          if (streaming) return;
          const q = (input || '').trim();
          if (!q) return;
          if (!currentId) newChat();
          const ensureId = currentId || chats[0]?.id;
          if (!ensureId) return; // wait next tick for new chat
          setInput('');
          setCurrentId(ensureId);
          // append user
          setChats(prev => prev.map(c => c.id === ensureId ? ({ ...c, messages: [...c.messages, { role: 'user', content: q }], updated: Date.now() }) : c));
          setTimeout(setTitleFromFirstUser, 0);

          const thisRid = newRid();
          setRid(thisRid);
          setStreaming(true);
          // placeholder assistant
          let assistantIndex = -1;
          setChats(prev => prev.map(c => {
            if (c.id !== ensureId) return c;
            assistantIndex = c.messages.length;
            return { ...c, messages: [...c.messages, { role: 'assistant', content: 'Thinking…' }] };
          }));

          const es = new EventSource('/stream?query=' + encodeURIComponent(q) + '&rid=' + encodeURIComponent(thisRid));
          let raw = '';
          let final = '';
          let pending = '';
          let mode = 'answer';
          const OPEN = '<Think>';
          const CLOSE = '</Think>';

          function updateAssistantContent(text, reasoningFragment = '') {
            setChats(prev => prev.map(c => {
              if (c.id !== ensureId) return c;
              const msgs = c.messages.slice();
              const cur = { ...(msgs[assistantIndex] || { role: 'assistant', content: '' }) };
              cur.content = text;
              if (reasoningFragment) {
                const prevR = cur.reasoning || '';
                cur.reasoning = (prevR + (prevR ? '\n' : '') + reasoningFragment).trim();
              }
              msgs[assistantIndex] = cur;
              return { ...c, messages: msgs, updated: Date.now() };
            }));
          }
          function flushPending() {
            if (!pending) return;
            if (mode === 'think') {
              updateAssistantContent(final, pending);
            } else {
              final += pending;
              updateAssistantContent(final);
            }
            pending = '';
          }
          es.onmessage = (e) => {
            const data = e.data || '';
            if (data === 'DONE') {
              flushPending();
              const reasoning = extractReasoning(raw);
              const clean = (stripThinkTags(final).trim() || stripThinkTags(raw).trim() || final.trim() || raw.trim());
              updateAssistantContent(clean, reasoning);
              es.close();
              setStreaming(false);
              setRid(null);
              return;
            }
            if (data.startsWith('META|')) return;
            raw += data;
            pending += data;
            while (true) {
              if (mode === 'think') {
                const closeIdx = pending.indexOf(CLOSE);
                if (closeIdx === -1) break;
                const thinkPart = pending.slice(0, closeIdx);
                updateAssistantContent(final, thinkPart);
                pending = pending.slice(closeIdx + CLOSE.length);
                mode = 'answer';
                continue;
              }
              const openIdx = pending.indexOf(OPEN);
              if (openIdx === -1) {
                const safe = Math.max(0, pending.length - (OPEN.length - 1));
                if (safe > 0) {
                  final += pending.slice(0, safe);
                  updateAssistantContent(final);
                  pending = pending.slice(safe);
                }
                break;
              }
              final += pending.slice(0, openIdx);
              updateAssistantContent(final);
              pending = pending.slice(openIdx + OPEN.length);
              mode = 'think';
            }
          };
          es.onerror = () => {
            es.close();
            flushPending();
            const clean = (stripThinkTags(final).trim() || final.trim());
            updateAssistantContent(clean);
            setStreaming(false);
            setRid(null);
            antdMessage.error('Connection lost');
          };
        }

        const sessions = chats;
        return (
          <Layout className="app-layout">
            <Sider className="sidebar" width={280} theme="dark">
              <div style={{ padding: 12 }}>
                <div className="sidebar-title">Conversations</div>
                <Space style={{ marginBottom: 12 }}>
                  <Button type="primary" onClick={newChat}>New Chat</Button>
                  <Button onClick={saveCurrentChat}>Save</Button>
                </Space>
                <Divider style={{ margin: '8px 0' }} />
                <List
                  size="small"
                  dataSource={sessions}
                  locale={{ emptyText: 'No conversations' }}
                  renderItem={(item) => (
                    <List.Item
                      style={{ padding: '6px 8px' }}
                      className={'session-item' + (item.id === currentId ? ' active' : '')}
                      onClick={() => selectChat(item.id)}
                      actions={[
                        <Popconfirm title="Delete chat?" onConfirm={() => deleteChat(item.id)} okButtonProps={{ danger: true }}>
                          <a key="del" style={{ color: '#ff7875' }}>Delete</a>
                        </Popconfirm>
                      ]}
                    >
                      <List.Item.Meta
                        title={<Text ellipsis style={{ maxWidth: 180 }}>{item.title || 'Untitled'}</Text>}
                        description={<Text type="secondary" style={{ fontSize: 12 }}>{new Date(item.updated || Date.now()).toLocaleString()}</Text>}
                      />
                    </List.Item>
                  )}
                />
              </div>
            </Sider>
            <Layout>
              <Header className="top-header">
                <Text strong>AI Chat Assistant</Text>
                <Space>
                  <Button onClick={saveCurrentChat}>Save</Button>
                  <Button danger onClick={cancel} disabled={!streaming}>Cancel</Button>
                </Space>
              </Header>
              <Content>
                <div className="chat-content">
                  <Messages items={current?.messages || []} />
                  <div className="input-bar">
                    <Space.Compact style={{ width: '100%' }}>
                      <TextArea
                        value={input}
                        onChange={e => setInput(e.target.value)}
                        onPressEnter={(e) => { if (!e.shiftKey) { e.preventDefault(); send(); } }}
                        autoSize={{ minRows: 1, maxRows: 6 }}
                        maxLength={window.MAX_QUERY_LENGTH || 2000}
                        placeholder="Type your message..."
                      />
                      <Button type="primary" onClick={send} disabled={streaming}>Send</Button>
                    </Space.Compact>
                  </div>
                </div>
              </Content>
            </Layout>
          </Layout>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
      {% endraw %}
    </script>
  </body>
</html>
